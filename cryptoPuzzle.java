/* CSC318 - Coursework 2
* Made by Thibault de Villèle (Student#933835) and Wiktor Nagorski (Student#871037)
* Created on 2018.03.06T23:00:13Z
*/

// Legacy from ./CryptoLib.java
import java.security.spec.InvalidKeySpecException;
import java.security.NoSuchAlgorithmException;
import java.security.InvalidKeyException;
// Why, exactly ?
import java.util.Arrays;
import java.util.Random;
// Needed for the uniqueness of puzzle numbers
import java.util.Set;
import java.util.HashSet;

// We need it for encryption of the puzzle
import javax.crypto.SecretKey;

public class cryptoPuzzle {

	//
	// The elements of the class are private, 
	// since we cannot access them from 
	// outside (security risk ¿¿(!)??)
	//
	private byte[] puzzleContent;	// 128 bits, all 0
	private byte[] puzzleNumber;	// 16 bits, random & unique
	private byte[] puzzleKey;	// 16 bits of random&unique then 48 bits of 0 (64b tot.)
	private SecretKey secretPuzzleKey;	// DES key obtained from the pseudo-randomly generated byte puzzleKey
	private byte[] puzzleCompleted; // Contains puzzleContent & puzzleNumber in one array


	//
	// Constructor, along with a seed value for the generator
	// Note : seed value starts at round 0 with value Integer.MIN_VALUE
	//        and is then the integer value of the last generated puzzle
	//
	public cryptoPuzzle(int seedValue) {
		//
		// Initialize the byte array of the puzzle contents
		// with a 128-bit value equal to 0
		//
		puzzleContent = new byte[16];
		Arrays.fill(puzzleContent,(byte)0x0); // Cast '0' to byte type

		//
		// Create random number generators for puzzle IDs and keys
		//
		Random numberGenerator;
		if (seedValue != Integer.MIN_VALUE) {
			numberGenerator = new Random(seedValue);
		} else {
			numberGenerator = new Random(System.currentTimeMillis());
		}
		Random keyGenerator = new Random(numberGenerator.nextLong());

		puzzleNumber = new byte[2];
		//
		// Using bitshifting, we can assure that 0<= valueToAdd <65536
		//
		puzzleNumber = CryptoLib.smallIntToByteArray(numberGenerator.nextInt()<<16>>>16);

		puzzleCompleted = new byte[18];
		//
		// Copy contents of all arrays into the 'completed' array.
		//
		System.arraycopy(puzzleContent, 0, puzzleCompleted, 0, puzzleContent.length);
		System.arraycopy(puzzleNumber, 0, puzzleCompleted, puzzleContent.length-1, puzzleNumber.length);

		//
		// Encryption ?!?
		//
		/*
		try {
			puzzleKey = CryptoLib.createKey(puzzleCompleted);
		} catch (InvalidKeySpecException e) {
			System.out.println("Puzzle not of good size, yo.");
		} catch (NoSuchAlgorithmException f) {
			System.out.println("No such algorithm, yo.");
		} catch (InvalidKeyException g) {
			System.out.println("Invalid key, yo.");
		}
		*/
	}

	public void regenerateID() {
		//
		// If we need to regenerate the ID,
		// we need to create a random generator,
		// and recompute a new ID value
		//
		Random keyGenerator = new Random(System.currentTimeMillis());

		//
		// Temp array for storing old number of puzzle
		//
		byte[] tempArray = new byte[this.getNumber().length];
		System.arraycopy(this.puzzleNumber,0,tempArray,0,this.puzzleNumber.length);
		//
		// While it's the same, change the thing to something else
		//
		while (Arrays.equals(this.puzzleNumber, tempArray)) {
			byte[] newValue = CryptoLib.smallIntToByteArray(keyGenerator.nextInt()<<16>>>16);
			System.arraycopy(newValue, 0, this.puzzleNumber, 0, newValue.length);
		}
	}

	public static cryptoPuzzle[] generatePuzzles(int numberOfPuzzlesToGenerate) {
		//
		// Create an array of puzzles
		//
		cryptoPuzzle[] puzzleTable = new cryptoPuzzle[numberOfPuzzlesToGenerate];
		int seedValuesForPuzzles = Integer.MIN_VALUE;
		//
		// Create a set that'll store every puzzle ID generated
		//
		Set<Integer> puzzleIDs = new HashSet<Integer>();

		//
		// In this array, do :
		//
		for (int i = 0; i < numberOfPuzzlesToGenerate; i++) {
			//
			// Create a new puzzle and store it
			//
			puzzleTable[i] = new cryptoPuzzle(seedValuesForPuzzles);
			//
			// Get the int value of the puzzle's ID
			//
			int newID = CryptoLib.byteArrayToSmallInt(puzzleTable[i].getNumber());
			//
			// Verify if this ID has not been used before
			//
			if (!puzzleIDs.contains(newID)) {
				//
				// If the ID is NOT in the set, add it and move on.
				//
				puzzleIDs.add(newID);
			} else {
				//
				// While the generated values are in the set, ...
				//
				while (puzzleIDs.contains(newID)) {
					//
					// ... regenerate them.
					//
					puzzleTable[i].regenerateID();
					newID = CryptoLib.byteArrayToSmallInt(puzzleTable[i].getNumber());
				}
				puzzleIDs.add(newID);
			}
			//
			// Use the ID of the newly created puzzle as a seed
			// for the random generators of the next puzzle
			//
			seedValuesForPuzzles = CryptoLib.byteArrayToSmallInt(puzzleTable[i].getNumber());
		}
		//
		// Return generated puzzles
		//
		return puzzleTable;
	}

	public byte[] getNumber() {
		return puzzleNumber;
	}

	public byte[] getContent() {
		return puzzleContent;
	}

	public int getContentLength() {
		return puzzleContent.length;
	}

	public void changeNumber(byte[] newPuzzleNumber) {
		//
		// Copy the new number into the puzzleNumber attribute of the element called upon.
		//
		System.arraycopy(newPuzzleNumber, 0, this.puzzleNumber, 0, newPuzzleNumber.length);
	}
}