/* CSC318 - Coursework 2
* Made by Thibault de Villèle (Student#933835) and Wiktor Nagorski (Student#871037)
* Created on 2018.03.06T23:00:13Z
*/

// Legacy from ./CryptoLib.java
import java.security.spec.InvalidKeySpecException;
import java.security.NoSuchAlgorithmException;
import java.security.InvalidKeyException;
// Why, exactly ?
import java.util.Arrays;
import java.util.Base64;
import java.util.Random;
// Needed for the uniqueness of puzzle numbers
import java.util.Set;
import java.util.HashSet;
import java.lang.Exception;

// Needed for all the writing to a file stuff
import java.io.FileOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.lang.NullPointerException;
import java.io.IOException;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
// We need it for encryption of the puzzle
import javax.crypto.SecretKey;

/**
 * Class for Alice's part of the job.
 * 
 * This class allows Alice to generate her puzzles, 
 * write them to a binary file and look up the shared 
 * key afterwards.
 */
public class cryptoPuzzle {

	//
	// The elements of the class are private,
	// since we cannot access them from
	// outside (security risk ¿¿(!)??)
	//
	public byte[] puzzleContent; // 128 bits, all 0
	public byte[] puzzleNumber; // 16 bits, random & unique
	public byte[] puzzleEncryptionKey; // 16 bits of random&unique then 48 bits of 0 (64b tot.)
	public byte[] puzzleSharedKey; // Randomly generated 64 bits DES key
	private SecretKey secretPuzzleKey; // DES key obtained from the pseudo-randomly generated byte puzzleKey
	private String cipheredPuzzle; // Encrypted ciphertext emanated from DES(puzzleCompleted,secretPuzzleKey)

	/**
	 * Basic (and only) constructor of a cryptoPuzzle.
	 * <p>
	 * Note : seed value starts at round 0 with value Integer.MIN_VAL, and is then
	 * the integer value of the last generated puzzle.
	 * </p>
	 * Here's a list of steps the constructor does :
	 * <ul>
	 * <li>- Initialises the {@code puzzleContent} variable with 128 bits of 0 (uses
	 * {@code java.util.Arrays.fill()})</li>
	 * <li>- Create 2 PRNG to generate a random puzzle ID and a random puzzle key
	 * (uses {@code java.util.Random})</li>
	 * <li>- We then create a random puzzle ID and a random puzzle key :</li>
	 * <ul>
	 * <li>- We take the next number issued by the PRNG</li>
	 * <li>- We use bitshifting to ensure the value of this integer is always
	 * confined to the [0; 65536[ interval. Since Integers in Java are 32-bit long,
	 * we can just shift them to the left by 16 bits, and shift them back to the
	 * right by 16 bits. As such, the upper half of the 32 bits representing the
	 * Integer are padded with 0, and thus the integer is just like a {@code short}
	 * number.</li>
	 * </ul>
	 * <li>- We now generate a shared key that will be used for message encryption once Bob found it.
	 * <li>- We use {@code CryptoLib.createKey()} to generate the
	 * {@code secretPuzzleKey} variable for the puzzle, used later for
	 * encryption.</li>
	 * </ul>
	 * 
	 * @author Thibault de Villèle
	 * @param seedValue
	 *            the seed value passed on to the constructor to seed the PRNG for
	 *            the puzzle ID. For the first iteration in
	 *            {@code generatePuzzles()}, we use {@code Integer.MIN_VALUE} as a
	 *            seed.
	 */
	public cryptoPuzzle(int seedValue) {
		//
		// Initialize the byte array of the puzzle contents
		// with a 128-bit value equal to 0
		//
		puzzleContent = new byte[16];
		Arrays.fill(puzzleContent, (byte) 0x0); // Cast '0' to byte type

		//
		// Create random number generators for puzzle IDs and keys
		//
		Random numberGenerator;
		if (seedValue != Integer.MIN_VALUE) {
			numberGenerator = new Random(seedValue);
		} else {
			numberGenerator = new Random(System.currentTimeMillis());
		}
		Random keyGenerator = new Random(numberGenerator.nextLong());

		puzzleNumber = new byte[2];
		//
		// Using bitshifting, we can assure that 0<= valueToAdd <65536 and
		// that the puzzle key is 16 bits long and padded of 48 '0' to the right
		// (Since Integers in Java are 32bits, we can shift them by 16 to get a
		// 16bit value, and shift them back to move the '0' padding the other way)
		//
		puzzleNumber = CryptoLib.smallIntToByteArray(numberGenerator.nextInt() << 16 >>> 16);
		puzzleEncryptionKey = new byte[8];
		byte[] keyGenerated = CryptoLib.smallIntToByteArray(keyGenerator.nextInt() << 16 >>> 16);
		System.arraycopy(keyGenerated, 0, puzzleEncryptionKey, 0, keyGenerated.length);
		//
		// NOTE : the first two bytes of puzzleKey[] are now populated with a number <
		// 65536
		//

		//
		// We now generate a random key that will be used for encrypting Alice's 
		// and Bob's messages later on
		//
		puzzleSharedKey = new byte[8];
		try {
			puzzleSharedKey = cryptoPuzzle.generateRandomKey();
		} catch (NoSuchAlgorithmException e1) {
			e1.printStackTrace();
		}

		//
		// Now, we have to generate the SecretKey object for encryption later on
		// (and a buncha catch blocks for the differents exceptions thrown)
		//
		try {
			secretPuzzleKey = CryptoLib.createKey(puzzleEncryptionKey);
		} catch (InvalidKeyException e) {
			System.out.print("Caught InvalidKeyException in puzzle creation : " + e.getMessage());
		} catch (InvalidKeySpecException e) {
			System.out.print("Caught InvalidKeySpecException in puzzle creation : " + e.getMessage());
		} catch (NoSuchAlgorithmException e) {
			System.out.print("Caught NoSuchAlgorithmException in puzzle creation : " + e.getMessage());
		}
	}

	/**
	 * Generates a random key in the form of a byte array
	 * @author Wiktor Nagorski
	 */
	public static byte[] generateRandomKey() throws NoSuchAlgorithmException {
		KeyGenerator keyGenerator = KeyGenerator.getInstance("DES");
		keyGenerator.init(56);
		SecretKey secretKey = keyGenerator.generateKey();
		String encodedKey = Base64.getEncoder().encodeToString(secretKey.getEncoded());
		byte[] encodedKeyByte = Base64.getDecoder().decode(encodedKey);
		return encodedKeyByte;
	}

	/** Regenerating new puzzles IDs
	 * 
	 * If we need to regenerate the ID of a puzzle, we need to create a random generator, 
	 * and recompute a new ID value. We then store this value in a temporary 
	 * array, and then while the value generated is the same as the one we 
	 * started with, we regenerate a new ID.
	 */
	public void regenerateID() {
		//
		// If we need to regenerate the ID,
		// we need to create a random generator,
		// and recompute a new ID value
		//
		Random keyGenerator = new Random(System.currentTimeMillis());

		//
		// Temp array for storing old number of puzzle
		//
		byte[] tempArray = new byte[this.getNumber().length];
		System.arraycopy(this.puzzleNumber, 0, tempArray, 0, this.puzzleNumber.length);
		//
		// While it's the same, change the thing to something else
		//
		while (Arrays.equals(this.puzzleNumber, tempArray)) {
			byte[] newValue = CryptoLib.smallIntToByteArray(keyGenerator.nextInt() << 16 >>> 16);
			System.arraycopy(newValue, 0, this.puzzleNumber, 0, newValue.length);
		}
	}

	/**
	 * Returns the cipher of the generated puzzle. (just a getter method, no need to document it)
	 */
	public String getCipher() throws Exception {
		if (cipheredPuzzle == "") {
			throw new Exception("Puzzle was not successfully ciphered");
		} else {
			return cipheredPuzzle;
		}
	}

	/**
	 * Returns the ID of the generated puzzle. (just a getter method, no need to document it)
	 */
	public byte[] getNumber() {
		return puzzleNumber;
	}

	/**
	 * Returns the content of the generated puzzle. (just a getter method, no need to document it)
	 */
	public byte[] getContent() {
		return puzzleContent;
	}

	/**
	 * Copies the value of newPuzzleNumber into the puzzleNumber variable of the puzzle
	 */
	public void changeNumber(byte[] newPuzzleNumber) {
		//
		// Copy the new number into the puzzleNumber attribute of the element called
		// upon.
		//
		System.arraycopy(newPuzzleNumber, 0, this.puzzleNumber, 0, newPuzzleNumber.length);
	}

	/**
	 * Generates an array of puzzles, only to be returned to the caller.
	 *
	 * This function uses a `Set` object such as the puzzle IDs are all 
	 * unique. If an ID is in the set, it has already been used (much 
	 * faster than looking up iteratively every puzzle number)
	 * @author Thibault de Villèle
	 */	
	public static cryptoPuzzle[] generatePuzzles(int numberOfPuzzlesToGenerate) {
		//
		// Create an array of puzzles
		//
		cryptoPuzzle[] puzzleTable = new cryptoPuzzle[numberOfPuzzlesToGenerate];
		int seedValuesForPuzzles = Integer.MIN_VALUE;
		//
		// Create a set that'll store every puzzle ID generated
		//
		Set<Integer> puzzleIDs = new HashSet<Integer>();

		//
		// In this array, do :
		//
		for (int i = 0; i < numberOfPuzzlesToGenerate; i++) {
			//
			// Create a new puzzle and store it
			//
			puzzleTable[i] = new cryptoPuzzle(seedValuesForPuzzles);
			//
			// Get the int value of the puzzle's ID
			//
			int newID = CryptoLib.byteArrayToSmallInt(puzzleTable[i].getNumber());
			//
			// Verify if this ID has not been used before
			//
			if (!puzzleIDs.contains(newID)) {
				//
				// If the ID is NOT in the set, add it and move on.
				//
				puzzleIDs.add(newID);
			} else {
				//
				// While the generated values are in the set, ...
				//
				while (puzzleIDs.contains(newID)) {
					//
					// ... regenerate them.
					//
					puzzleTable[i].regenerateID();
					newID = CryptoLib.byteArrayToSmallInt(puzzleTable[i].getNumber());
				}
				puzzleIDs.add(newID);
			}

			//
			// Use the ID of the newly created puzzle as a seed
			// for the random generators of the next puzzle
			//
			seedValuesForPuzzles = CryptoLib.byteArrayToSmallInt(puzzleTable[i].getNumber());
		}

		//
		// Return generated puzzles
		//
		return puzzleTable;
	}

	// Method which given a puzzle number and array of not encrypted puzzles,
	// returns the shared key corresponding to that puzzle
	public static byte[] sharedKeyLookup(byte[] puzzleNumber, cryptoPuzzle[] puzzleTable) {
		byte[] sharedKey = new byte[8];
		for (int i = 0; i < puzzleTable.length; i++) {
			if (CryptoLib.getHexStringRepresentation(puzzleTable[i].puzzleNumber)
					.equalsIgnoreCase(CryptoLib.getHexStringRepresentation(puzzleNumber))) {
				sharedKey = puzzleTable[i].puzzleSharedKey;
				break;
			}

		}
		return sharedKey;
	}

	/**
	 * Writes a cryptoPuzzle array to a file. We first create a
	 * {@code FileOutputStream} from a {@code File} object, and 
	 * then we write the puzzles to it following this procedure :
	 * 
	 * <ul>
	 * <li>- We get the puzzle's data</li>
	 * <li>- We dump it into a variable that contains the whole puzzle using a {@code ByteArrayOutputStream}.</li>
	 * <li>- We use cryptoPuzzle.encrypt() to encrypt the puzzle and them, we write it to the file.</li>
	 * </ul>
	 * 
	 * @param puzzleTable
	 *            the array of puzzles to write to the file
	 * @param fileNameRequested
	 *            the name and or path of the file you want to write to
	 * @throws IOException
	 * 			If the file has a problem, it can throw an IOException.
	 * @return The function is returning nothing, but stops if an exception is
	 *         caught whilst opening the file
	 * @author Wiktor Nagorski & Thibault de Villèle
	 */
	public static void writePuzzlesToBinary(cryptoPuzzle[] puzzleTable, String fileNameRequested) throws IOException {
		//
		// We have to create a FileOutputStream to write the contents of the puzzle
		// array to the file
		//
		File requestedFile;
		FileOutputStream fileStream;
		try {
			requestedFile = new File(fileNameRequested);
			fileStream = new FileOutputStream(requestedFile);
		} catch (NullPointerException e) {
			System.out.println("Exception : Null pointer on file opening.\n" + e.getMessage());
			return;
		} catch (FileNotFoundException e) {
			System.out.println("Exception : File not found upon file opening.\n" + e.getMessage());
			return;
		}

		for (int i = 0; i < puzzleTable.length; i++) {
			//
			// We get the puzzle data to use it just a bit further down
			//
			byte[] zeros = puzzleTable[i].puzzleContent;
			byte[] puzzleNumber = puzzleTable[i].puzzleNumber;
			byte[] sharedKey = puzzleTable[i].puzzleSharedKey;

			//
			// We create a byte array that'll encompass the whole puzzle
			//
			byte[] completePuzzle = new byte[26];

			//
			// We then dump all the puzzle into the completePuzzle using a byte stream
			//
			ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
			try {
				byteArrayOutputStream.write(zeros);				
				byteArrayOutputStream.write(puzzleNumber);
				byteArrayOutputStream.write(sharedKey);
			} catch (IOException e) {
				e.printStackTrace();
			}
			completePuzzle = byteArrayOutputStream.toByteArray();
			byteArrayOutputStream.close();

			try {
				byte[] encryptedPuzzle = cryptoPuzzle.encrypt(completePuzzle, puzzleTable[i].secretPuzzleKey);
				fileStream.write(encryptedPuzzle);
			} catch (IOException e) {
				System.out.println("IOException on fileStream.write(byte[],int,int) " + e.getMessage());
			} catch (Exception e) {
				System.out.println("The puzzle in position " + i + " has not been ciphered yet. Iterating over it. " + e.getMessage() + " " + e.getClass());
			}
		}
		fileStream.close();
	}

	/**
	 * Slightly different version of the DES.encrypt() function. It 
	 * only returns the byte array, without converting it into a String first.
	 * @author Wiktor Nagorski
	 */
	public static byte[] encrypt(byte[] message, SecretKey secretKey) throws Exception {
		Cipher cipher = Cipher.getInstance("DES");
		cipher.init(Cipher.ENCRYPT_MODE, secretKey);
		byte[] encryptedByte = cipher.doFinal(message);
		return encryptedByte;
	}
}