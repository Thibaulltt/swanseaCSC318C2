/* CSC318 - Coursework 2
* Made by Thibault de Villèle (Student#933835) and Wiktor Nagorski (Student#871037)
* Created on 2018.03.06T23:00:13Z
*/

// Legacy from ./CryptoLib.java
import java.security.spec.InvalidKeySpecException;
import java.security.NoSuchAlgorithmException;
import java.security.InvalidKeyException;
// Why, exactly ?
import java.util.Arrays;
import java.util.Random;
// Needed for the uniqueness of puzzle numbers
import java.util.Set;
import java.util.HashSet;

import java.lang.Exception;

// Needed for all the writing to a file stuff
import java.io.FileOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.lang.NullPointerException;
import java.io.IOException;

// We need it for encryption of the puzzle
import javax.crypto.SecretKey;

public class cryptoPuzzle {

	//
	// The elements of the class are private, 
	// since we cannot access them from 
	// outside (security risk ¿¿(!)??)
	//
	private byte[] puzzleContent;	// 128 bits, all 0
	private byte[] puzzleNumber;	// 16 bits, random & unique
	private byte[] puzzleKey;	// 16 bits of random&unique then 48 bits of 0 (64b tot.)
	private SecretKey secretPuzzleKey;	// DES key obtained from the pseudo-randomly generated byte puzzleKey
	private String puzzleCompleted; // Contains puzzleContent & puzzleNumber in one array
	private String cipheredPuzzle;	// Encrypted ciphertext emanated from DES(puzzleCompleted,secretPuzzleKey)


	//
	// Constructor, along with a seed value for the generator
	// Note : seed value starts at round 0 with value Integer.MIN_VALUE
	//        and is then the integer value of the last generated puzzle
	//
	public cryptoPuzzle(int seedValue) {
		//
		// Initialize the byte array of the puzzle contents
		// with a 128-bit value equal to 0
		//
		puzzleContent = new byte[16];
		Arrays.fill(puzzleContent,(byte)0x0); // Cast '0' to byte type

		//
		// Create random number generators for puzzle IDs and keys
		//
		Random numberGenerator;
		if (seedValue != Integer.MIN_VALUE) {
			numberGenerator = new Random(seedValue);
		} else {
			numberGenerator = new Random(System.currentTimeMillis());
		}
		Random keyGenerator = new Random(numberGenerator.nextLong());

		puzzleNumber = new byte[2];
		//
		// Using bitshifting, we can assure that 0<= valueToAdd <65536 and
		// that the puzzle key is 16 bits long and padded of 48 '0' to the right
		// (Since Integers in Java are 32bits, we can shift them by 16 to get a
		// 16bit value, and shift them back to move the '0' padding the other way)
		//
		puzzleNumber = CryptoLib.smallIntToByteArray(numberGenerator.nextInt()<<16>>>16);
		puzzleKey = new byte[8];
		byte[] keyGenerated = CryptoLib.smallIntToByteArray(keyGenerator.nextInt()<<16>>>16);
		System.arraycopy(keyGenerated,0,puzzleKey,0,keyGenerated.length);
		//
		// NOTE : the first two bytes of puzzleKey[] are now populated with a number < 65536
		//

		//
		// Now, we have to generate the SecretKey object for encryption later on
		//
		try {
			secretPuzzleKey = CryptoLib.createKey(puzzleKey);
		} catch (InvalidKeyException e) {
			System.out.print("Caught exception : "+e.getMessage());
		} catch (InvalidKeySpecException e) {
			System.out.print("Caught exception : "+e.getMessage());
		} catch (NoSuchAlgorithmException e) {
			System.out.print("Caught exception : "+e.getMessage());
		}
	}

	public void regenerateID() {
		//
		// If we need to regenerate the ID,
		// we need to create a random generator,
		// and recompute a new ID value
		//
		Random keyGenerator = new Random(System.currentTimeMillis());

		//
		// Temp array for storing old number of puzzle
		//
		byte[] tempArray = new byte[this.getNumber().length];
		System.arraycopy(this.puzzleNumber,0,tempArray,0,this.puzzleNumber.length);
		//
		// While it's the same, change the thing to something else
		//
		while (Arrays.equals(this.puzzleNumber, tempArray)) {
			byte[] newValue = CryptoLib.smallIntToByteArray(keyGenerator.nextInt()<<16>>>16);
			System.arraycopy(newValue, 0, this.puzzleNumber, 0, newValue.length);
		}
	}

	public void encryptPuzzle() {
		//
		// In this function, we encrypt the puzzle.
		// 

		//
		// Due to how DES.encrypt() is formed, we need to 
		// first get the String representation of the 
		// puzzle's content and ID
		//
		this.puzzleCompleted = "";
		for (int i = 0; i < puzzleContent.length; i++) {
			this.puzzleCompleted += Byte.toString(puzzleContent[i]);
		}
		for (int i = 0; i < puzzleNumber.length; i++) {
			this.puzzleCompleted += Byte.toString(puzzleNumber[i]);
		}

		//
		// We also have to take the SecretKey of the puzzle 
		// into account for the encryption process
		//
		try {
			//
			// We now have to create a DES object
			// 
			DES cipherEngine = new DES();
			this.cipheredPuzzle = cipherEngine.encrypt(this.puzzleCompleted, secretPuzzleKey);
		} catch (Exception e) {
			System.out.println("Well you have one ERROR : "+e.getMessage());
		}
	}

	public static cryptoPuzzle[] generatePuzzles(int numberOfPuzzlesToGenerate) {
		//
		// Create an array of puzzles
		//
		cryptoPuzzle[] puzzleTable = new cryptoPuzzle[numberOfPuzzlesToGenerate];
		int seedValuesForPuzzles = Integer.MIN_VALUE;
		//
		// Create a set that'll store every puzzle ID generated
		//
		Set<Integer> puzzleIDs = new HashSet<Integer>();

		//
		// In this array, do :
		//
		for (int i = 0; i < numberOfPuzzlesToGenerate; i++) {
			//
			// Create a new puzzle and store it
			//
			puzzleTable[i] = new cryptoPuzzle(seedValuesForPuzzles);
			//
			// Get the int value of the puzzle's ID
			//
			int newID = CryptoLib.byteArrayToSmallInt(puzzleTable[i].getNumber());
			//
			// Verify if this ID has not been used before
			//
			if (!puzzleIDs.contains(newID)) {
				//
				// If the ID is NOT in the set, add it and move on.
				//
				puzzleIDs.add(newID);
			} else {
				//
				// While the generated values are in the set, ...
				//
				while (puzzleIDs.contains(newID)) {
					//
					// ... regenerate them.
					//
					puzzleTable[i].regenerateID();
					newID = CryptoLib.byteArrayToSmallInt(puzzleTable[i].getNumber());
				}
				puzzleIDs.add(newID);
			}
			puzzleTable[i].encryptPuzzle();
			//
			// Use the ID of the newly created puzzle as a seed
			// for the random generators of the next puzzle
			//
			seedValuesForPuzzles = CryptoLib.byteArrayToSmallInt(puzzleTable[i].getNumber());
		}

		//
		// Return generated puzzles
		//
		return puzzleTable;
	}

	public static void writeToFile(cryptoPuzzle[] puzzleTable, String fileNameRequested) {
		//
		// We have to create a FileOutputStream to write the contents of the puzzle array to the file
		//
		File requestedFile;
		FileOutputStream fileStream;
		try { 
			requestedFile = new File(fileNameRequested);
			fileStream = new FileOutputStream(requestedFile);
		} catch (NullPointerException e) {
			System.out.println("Exception : Null pointer on file opening ( cryptoPuzzle.java @ 221 )\n"+e.getMessage());
			return;
		} catch (FileNotFoundException e) {
			System.out.println("Exception : File not found upon file opening ( cryptoPuzzle.java @ 222 )\n"+e.getMessage());	
			return;
		}
		//
		// And now we just iterate over the array, writing every ciphertext to the file
		//
		int fileCursorPosition = 0;
		for (int i = 0; i < puzzleTable.length; i++) {
			try {
				String cipherText = puzzleTable[i].getCipher();
				byte[] cipherTextBytes = cipherText.getBytes();
				fileStream.write(cipherTextBytes);
				fileCursorPosition += cipherTextBytes.length;
			} catch (IOException e) {
				System.out.println("IOException on fileStream.write(byte[],int,int) "+e.getMessage());
			} catch (Exception e) {
				System.out.println("The puzzle in position "+i+" has not been ciphered yet. Iterating over it. "+e.getMessage()+" "+e.getClass());
			}
		}
	}

	public String getCipher() throws Exception {
		if (cipheredPuzzle == "") {
			throw new Exception("Puzzle was not successfully ciphered");
		} else {
			return cipheredPuzzle;
		}
	}

	public byte[] getNumber() {
		return puzzleNumber;
	}

	public byte[] getContent() {
		return puzzleContent;
	}

	public int getContentLength() {
		return puzzleContent.length;
	}

	public void changeNumber(byte[] newPuzzleNumber) {
		//
		// Copy the new number into the puzzleNumber attribute of the element called upon.
		//
		System.arraycopy(newPuzzleNumber, 0, this.puzzleNumber, 0, newPuzzleNumber.length);
	}
}
